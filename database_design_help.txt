d1 r1 r2 r3
session_01

database
database mangement system(dbms): sqlite , postgresql, .....
crud
relational database: sql langunge
nosql
database adminstrator(DBAs): access levels 

--------------------------------------------------------------
d1 r1 r2 r3
session_02

sql 
use postgresql
[optional]
(forced)

create database one;
disconnect from pgadmin or other user
drop database if exists one;

drop database if exists one with (force);

create database one with [options];
create database one with owner postgres encoding= 'utf8';

alter database one rename to two;

--------------------------------------------------------------
d1 r1 r2 r3
session_03

table
CREATE TABLE table_name (
    column1 data_type [constraints],
    column2 data_type [constraints],
    ...
);

create table users (email varchar(60) , password varchar(60),age smallint, address varchar(1000))

drop table users;

unique
not null
create table users (email varchar(60) unique not null , password varchar(60) not null ,age smallint, address varchar(
1000));

alter table name [actions];

alter table users drop column address;

alter table users add column address varchar(1000) unique;

--------------------------------------------------------------
d1 r1 r2 r3
session_04

select: read data

two=# \c shop;
You are now connected to database "shop" as user "postgres".
shop=# 

select * from employees;
select title, address from employees;

distinct
select distinct title from employees;
select distinct title, address from employees;

count 
select count(title) from employees;

count distinct
select count(distinct title) from employees;

select customerid , shippeddate - orderdate from orders;

where
select * from order_details where quantity<=10 ;
select * from orders where orderdate > '1997-07-07';

and 
select * from customers where country='Germany' and city='Berlin';

or
select * from customers where country='Germany' or city='Berlin';

not 
select * from customers where not country='Germany' and city='Berlin';
select * from customers where not country='Germany' and (city='Berlin' or city='paris');

between
select * from order_details  WHERE unitprice BETWEEN 10 and 43 ;

in
select * from customers  WHERE country in ('Germany' , 'Mexico', 'Spain') ;

ORDER by asc , desc
select DISTINCT country , city  from customers ORDER by country asc , city desc ;

min max sum avg
select min(unitprice) from order_details ;
select max(unitprice) from order_details ;
select avg(unitprice) from order_details ;
select sum(unitprice) from order_details ;

like 
%: multi char
_: on char
select * from customers where companyname like 'A_f%';

* + - / ....
as: name for name column
select unitprice * quantity as totla from order_details;

LIMIT
select unitprice * quantity as totla from order_details LIMIT 10;

--------------------------------------------------------------
d2
session_05

INSERT INTO customers (customerid, companyname, country) VALUES ('1', 'one', 'iran') RETURNING *;

delete from customers where conditon(forced)
delete from customers where country='iran';

update customers set country ='iri' , companyname='sss' WHERE conditon(forced)
update customers set country ='iri' , companyname='sss' WHERE customerid='3'

select into: create new table by other data tables
select * into new_customers from customers where country in ('Mexcio' , 'Germany')

select into: use other data table with out create new table:
select into new_customers select * from customers where country='Spain';

--------------------------------------------------------------

session_06

primary_key = unique not null 

id 

serial and bigserial = autoincrement integer

CREATE table students(id serial PRIMARY key,name text, phone integer);
insert into students (name , phone) VALUES ('sss' , 12345)

--------------------------------------------------------------

session_07

foriegn_key = refreces in postgresql

refreces <table name> <primary key> 

ON DELETE restrict: 
اگر سعی کنی رکورد والد (Parent) را حذف کنی در حالی که رکوردهای فرزند (Child) هنوز به آن اشاره دارند، عملیات حذف ممنوع (Restrict) می‌شود.

ON DELETE no action:
تا وقتی که رکوردهای فرزند وجود دارند، اجازه‌ی حذف رکورد والد را نداری.

ON DELETE cascade:
 اگر رکورد والد (Parent) را حذف کنی، تمام رکوردهای فرزند (Child) که به آن اشاره می‌کنند، به صورت خودکار حذف می‌شوند.

ON DELETE set null:
فرزندها باقی می‌مانند ولی کلید خارجی آن‌ها NULL می‌شود.

ON DELETE set default:
کلید خارجی فرزندها به مقدار DEFAULT تغییر می‌کند

ON UPDATE:  if delete parent table, dont delete data and update in child table

--------------------------------------------------------------

session_08

relation

one_to_many

one_to_one

many_to_many: internal table

boot 
author
PRIMARY KEY (book , author)

--------------------------------------------------------------

session_11

Normalizations

**1NF (First Normal Form)** اولین مرحله از نرمال‌سازی پایگاه داده است که هدفش **جلوگیری از داده‌های تکراری و پیچیده (غیراتمی)** در ستون‌هاست.

### قوانین 1NF:

1. **هر ستون باید فقط یک مقدار (Atomic Value) داشته باشد.**
   یعنی نمی‌تونیم توی یک سلول لیست یا چند مقدار قرار بدیم.

2. **سطرهای جدول نباید تکراری باشند.**

3. **ترتیب ردیف‌ها و ستون‌ها مهم نیست.**

---

## 🧱 مثال ساده:

### ❌ جدول نقض‌کننده 1NF:

| StudentID | Name | Courses       |
| --------- | ---- | ------------- |
| 1         | Ali  | Math, Physics |
| 2         | Sara | Chemistry     |

در این مثال ستون `Courses` حاوی چند مقدار است، که نقض 1NF محسوب می‌شود.

---

### ✅ شکل نرمال‌شده (1NF):

| StudentID | Name | Course    |
| --------- | ---- | --------- |
| 1         | Ali  | Math      |
| 1         | Ali  | Physics   |
| 2         | Sara | Chemistry |

هر مقدار جدا شده و جدول در فرم 1NF قرار دارد.

---

## 🎯 چرا 1NF مهم است؟

* جستجو و گزارش‌گیری راحت‌تر می‌شود.
* داده‌ها منظم‌تر، تمیزتر و قابل تحلیل‌تر هستند.
* مرحله‌ای برای رسیدن به فرم‌های نرمال بعدی (2NF، 3NF، ...) است.

---------------------------------

**2NF (Second Normal Form)** یعنی:

> «یک جدول در 2NF است **اگر اولاً در 1NF باشد** و **ثانیاً هر ستون غیر کلیدی کاملاً به کلید اصلی وابسته باشد** (نه فقط بخشی از آن).»

---

## 💡 منظور از «وابستگی کامل به کلید اصلی» چیه؟

وقتی کلید اصلی جدول **ترکیبی** (composite key) باشه، ستون‌های غیرکلیدی نباید فقط به یک بخش از کلید وابسته باشن؛ بلکه باید **به کل کلید وابسته باشن.**

---

### 🔸 مثال نقض 2NF (جدول در 1NF هست ولی در 2NF نیست):

| StudentID | CourseID | StudentName | CourseName |
| --------- | -------- | ----------- | ---------- |
| 1         | 101      | Ali         | Math       |
| 1         | 102      | Ali         | Physics    |
| 2         | 101      | Sara        | Math       |

کلید اصلی: ترکیب `(StudentID, CourseID)`

🔴 مشکل:

* `StudentName` فقط به `StudentID` وابسته است.
* `CourseName` فقط به `CourseID` وابسته است.
* یعنی هر ستون به بخشی از کلید ترکیبی وابسته است → این نقض 2NF است.

---

## ✅ نرمال‌سازی به 2NF:

### 🔹 جدول: Student

| StudentID | StudentName |
| --------- | ----------- |
| 1         | Ali         |
| 2         | Sara        |

### 🔹 جدول: Course

| CourseID | CourseName |
| -------- | ---------- |
| 101      | Math       |
| 102      | Physics    |

### 🔹 جدول: Enrollment (رابط بین دانشجو و درس)

| StudentID | CourseID |
| --------- | -------- |
| 1         | 101      |
| 1         | 102      |
| 2         | 101      |

✅ حالا هر ستون فقط به کلید اصلی خودش کاملاً وابسته است → جدول‌ها در 2NF هستند.

---

## 🎯 خلاصه تفاوت 1NF و 2NF:

| فرم نرمال | قانون اصلی                | مشکل رایج                                               |
| --------- | ------------------------- | ------------------------------------------------------- |
| 1NF       | ستون‌ها باید اتمی باشند   | وجود لیست یا چند مقدار در یک سلول                       |
| 2NF       | وابستگی کامل به کلید اصلی | وجود ستون‌هایی که فقط به بخشی از کلید ترکیبی وابسته‌اند |

---------------------------------

## ✅ **3NF (Third Normal Form)** چیست؟

یک جدول در **فرم نرمال سوم (3NF)** قرار دارد اگر:

1. **در 2NF باشد**
2. و **هیچ وابستگی گذرا (transitive dependency)** بین ستون‌های غیرکلیدی و کلید اصلی وجود نداشته باشد.

---

## 📌 وابستگی گذرا یعنی چی؟

یعنی یک ستون غیرکلیدی **وابسته به ستون غیرکلیدی دیگری** باشد که خودش وابسته به کلید اصلی است.

به زبان ساده:

> اگر A → B و B → C، پس A → C یک **وابستگی گذرا** است.

---

## 🔸 مثال نقض 3NF (در 2NF هست ولی در 3NF نیست):

| EmployeeID | Name | DepartmentID | DepartmentName |
| ---------- | ---- | ------------ | -------------- |
| 1          | Ali  | 10           | IT             |
| 2          | Sara | 20           | HR             |

* **کلید اصلی:** `EmployeeID`
* `DepartmentID` به `EmployeeID` وابسته است ✅
* ولی `DepartmentName` به `DepartmentID` وابسته است ❌ (وابستگی گذرا)

---

## ✅ نرمال‌سازی به 3NF:

### 🔹 جدول: Employees

| EmployeeID | Name | DepartmentID |
| ---------- | ---- | ------------ |
| 1          | Ali  | 10           |
| 2          | Sara | 20           |

### 🔹 جدول: Departments

| DepartmentID | DepartmentName |
| ------------ | -------------- |
| 10           | IT             |
| 20           | HR             |

✅ حالا `DepartmentName` مستقیماً به کلید اصلی جدول خودش وابسته است. دیگر هیچ وابستگی گذرایی نداریم → جدول‌ها در 3NF هستند.

---

## 🔁 خلاصه فرم‌های نرمال:

| فرم نرمال | شرط اصلی                  | مثال نقض                                       |
| --------- | ------------------------- | ---------------------------------------------- |
| 1NF       | ستون‌ها باید اتمی باشند   | لیست داخل یک ستون                              |
| 2NF       | وابستگی کامل به کلید اصلی | ستون فقط به بخشی از کلید ترکیبی وابسته است     |
| 3NF       | عدم وابستگی گذرا          | ستون غیرکلیدی به ستون غیرکلیدی دیگر وابسته است |

---

## 🎯 چرا 3NF مهمه؟

* داده‌های تکراری رو کم می‌کنه
* تغییرات ساده‌تر و سریع‌تر میشن
* پایگاه داده قابل گسترش‌تر و نگه‌داری‌پذیرتر میشه

--------------------------------------------------------------
session_12

keys:

primary_key

foriegn_key

candidate_key

alternate_key


    کلید جایگزین یا Alternate Key یک فیلد یا مجموعه‌ای از فیلدهاست که به طور یکتا (Unique) یک رکورد رو مشخص می‌کنه، اما کلید اصلی (Primary Key) جدول نیست.

    معمولا برای پیدا کردن رکوردها از راهی غیر از کلید اصلی استفاده میشه.


Super Key = هر مجموعه‌ای از یک یا چند ستون که بتواند به طور یکتا یک رکورد را در جدول شناسایی کند.

    ممکن است شامل کلیدهای اضافه هم باشد (یعنی حداقل نباشد).

    از نظر نظریه پایگاه داده، Primary Key و Alternate Key هر دو زیرمجموعه‌ای از Super Key هستند، با این تفاوت که آن‌ها Minimal 


surrogate_key
یعنی کلید ساختگی — یک شناسه که هیچ معنای واقعی یا تجاری در داده‌ها نداره و فقط برای شناسایی یکتای رکوردها استفاده میشه.


natural_key یعنی کلیدی که از داده‌های واقعی (business data) می‌آد و خودش به طور طبیعی می‌تونه یک رکورد رو در جدول 


unique_key یا کلید یکتا یک Constraint (محدودیت) در پایگاه داده است که تضمین می‌کند مقدار یک ستون یا ترکیب چند ستون در همه رکوردهای جدول تکراری نباشد.

composite_key یعنی کلید مرکب — یک کلید که از ترکیب دو یا چند ستون ساخته شده تا به صورت یکتا هر رکورد جدول را مشخص کند.

simple_key یعنی کلیدی که فقط از یک ستون ساخته شده و می‌تواند رکورد را به صورت یکتا شناسایی کند.

compond_key = foriegn_key + composite_key

intelligent_key (که بعضی جاها بهش smart key یا smart identifier هم می‌گن) در طراحی پایگاه داده یعنی کلیدی که خودش داخلش اطلاعات معنادار و قابل‌تفسیر ذخیره می‌کند، برعکس یک surrogate_key که فقط یک شناسه بی‌معنی است.

--------------------------------------------------------------

session_13

unione distinct
    دو یا چند SELECT را با هم ترکیب می‌کند.

    به طور پیش‌فرض رکوردهای تکراری را حذف می‌کند (همانند DISTINCT).

    برای اینکه نتیجه ترکیب شود، تعداد ستون‌ها و نوع داده‌ها باید یکی باشد.

unione all
    UNION = (نتایج SELECT1 + SELECT2) با DISTINCT پیش‌فرض.

    اگر بخواهیم رفتار UNION بدون حذف تکراری‌ها را داشته باشیم → از UNION ALL استفاده می‌کنیم.

    اگر فقط یک جدول داریم و می‌خواهیم تکراری‌ها حذف شوند → از DISTINCT استفاده می‌کنیم.


intersect 
در SQL، INTERSECT نتایج مشترک بین دو کوئری را برمی‌گرداند.

EXCEPT = گرفتن رکوردهایی که در مجموعه اول هستند ولی در مجموعه دوم نیستند.

-- comment in sql 